- SRP 는 헷갈리기 쉬운데, 주요한 사항은 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 것이다.
- 커다란 함수를 작은 함수로 리팩토링 하는 저수준에서 사용되는 원칙이다.
- 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야만 한다.
-
- #+BEGIN_QUOTE
  하나의 모듈은 하나의 오직 하나의 액터에 대해서만 책임져야 한다.
  #+END_QUOTE
	- 모듈은 소스 파일이고, 액터는 변경을 요청하는 한 명 이상의 사람들을 가리킨다.
-
- 예시1 ) 우발적 중복
	- 상황
		- Employee 클래스 안에 CFO, CTO, COO 가 전부 사용하는 각각의 메서드를 다 넣는 경우가 있을 수 있다.
		- calculatepay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 쓰인다.
		- reportHour() 메서드는 인사팀에서 기능을 정의, COO 보고를 위해 쓰인다.
		- save() 메서드는 DBA가 기능을 정의하고, CTO보고를 위해 쓰인다.
	- 이처럼 세 메서드를 하나의 클래스에 배치하여 각각 다른 3개의 액터가 결합되어 버렸다.
	- 이 사항이 어떠한 정규 regularHours 라는 값을 참조 할 경우에는 올바르지 않은 수치가 입력되고 계산 될 수 있다.
	- 이러한 문제가 서로 다른 액터가 의존하는 코드를 가까이서 배치했기 때문에 많은 지출을 초래 할 수 있는 코드가 되는 셈이다.
-
- 예시2) 병합
	- 상황
		- 두 명의 서로 다른 개발자가, Employee 클래스 체크아웃 받은 이후에 변경사항을 적용하기 시작하고, 병합이 발생한다.
		- 많은 사람들이 서로 다른 목적을 동일한 소스 파일을 변경하는 경우에 해당한다.
		- 이에 따라서 각자 충돌하면서 각자 이해 관계에 맞는 소스 파일 수정시에 연루 된 많은 사람들이 영향을 받게 된다.
	- 이 문제에서 벗어나는 사항은 서로 다른 액터를 뒷받침하는 코드를 서로 분리 하는 것이다.
	- (즉 하나의 Employee 파일이 아닌 Employee를 상속 받거나 규칙을 할당받아서 실제로 구현 부에서 상세 사항을 각각 구현하게 된다면 이에 대한 처리를 진행할 수 있을 것이다.)
	-
	- 해결책
		- 데이터와 메서드를 분리하는 방식으로 아무런 메서드가 없는 EmployeeData 클래스를 생성해서 세 개의 클래스가 공유하도록 제작한다.
		  logseq.order-list-type:: number
			- 단점 : 개발자가 세가지 클래스를 인스턴스화 하고 추적해야 한다. 
			  logseq.order-list-type:: number
		- 이를 해결 하기 위한 퍼사드(Facade) 패턴이 있는데 EmployeeFacade에 코드는 없지만 이 클래스는 여러 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 "위임"하는 일을 책임진다. (일종의 Delegate 패턴) 
		  logseq.order-list-type:: number
			- 여기서 변환해서 중요한 업무 규칙 사항을 데이터와 가깝게 배치하는 방식을 선호하기도 하는데 비교적 덜 중요한 메서드를 퍼사드로 배치 할 수도 있다.
			  logseq.order-list-type:: number
			- 참고) https://velog.io/@bagt/Design-Pattern-Facade-Pattern-%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4
		- 여러 메서드가 하나의 가족을 이루고 메서드의 가족을 포함하는 각각의 클래스는 하나의 유효 범위로써 단일 책임의 원칙을 구현 할 수 있다.
		  logseq.order-list-type:: number
- #+BEGIN_IMPORTANT
  결론. 단일 책임 원칙 (SRP)는 메서드와 클래스 수준의 원칙이다.
  상위 수준에서도 다른 형태로 나타나는데
  컴포넌트 수준에서는 공통 폐쇄 원칙이 되고, 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.
  #+END_IMPORTANT
-