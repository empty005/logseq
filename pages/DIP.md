- 소스코드 의존성이 추상에 의존하며, 구체에는 의존하지 않는 시스템을 의미한다.
- 여기의 사항은 추상화된 인터페이스는 구체화된 구현체나 클래스에 비해 변동성이 낮다. 물론 구상과 설계가 잘 못 된다면 이 인터페이스의 변동성도 많겠지만 뛰어난 설계자의 경우에는 이 인터페이스의 변동성을 낮추려고 많은 노력을 기울인다. 
  이 원칙에 따르면 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 것이 아닌 안정된 추상 인터페이스를 선호하는 아키텍처를 의미한다.
- 변동성이 큰 구체 클래스를 참조하지 말라
  logseq.order-list-type:: number
	- 대신 추상 인터페이스를 참조하고, 객체 생성 방식을 강하게 제약하고, 추상 팩토리를 사용하도록 강제한다.
- 변동성이 큰 구체 클래스로부터 파생하지 말라
  logseq.order-list-type:: number
	- 상속은 소스 코드에 존재하는 모든 관계중에 변경하기 어렵다. 따라서 상속은 매우 신중하게 사용해야 한다. (클린 아키텍쳐에서는 권유하지 않는다.) -> 따라서 많은 클래스에서 커스텀에서는 final 을 붙이는 습관을 들여야 한다라고 swift에서는 고려 할 수 있다.
- 구체 함수를 오버라이드 하지 말라.
  logseq.order-list-type:: number
	- 대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 구체 함수를 오버라이드 하면 이러한 의존성이 제거되지 않으며, 의존성을 상속하게 되기 때문이다. 이를 해결하려면 추상 함수로 선언하고, 구현체에서 각자 용도에 맞게 재 구현 해야 한다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라. 
  logseq.order-list-type:: number
	- 클래스로써 쓸 생각하지 말고 구체화 하는 구현체의 경우에는 어디 가져다가 쓸 생각하지 말라는 소리다.
-
- 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전되는 것을 보고 의존성 역전이라고 부른다.
-
- 구체 컴포넌트에는 구체적인 의존성이 하나 있고, 따라서 DIP에 위배된다. DIP를 전부 제거 할 수는 없는데, 이 사항을 main 함수에서 생성하고 이를 전역 변수에서 관리하여 접근하는 형태로 사용한다.
-
-
- ## [[팩토리]]
	- 상단의 팩토리에 대한 개념이 등장
-
-