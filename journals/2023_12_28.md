- RxSwift 준비
	- 면접 문제 추출하기
	  collapsed:: true
		- **RxSwift와 RxCocoa의 차이점은 무엇인가요?**
			- **RxSwift**: RxSwift는 ReactiveX 프로그래밍 패러다임을 Swift로 구현한 라이브러리입니다.
			- **RxCocoa**: RxCocoa는 Cocoa 프레임워크에 ReactiveX 패러다임을 적용한 것으로, UIKit 및 Cocoa Touch의 클래스들에 RxSwift의 기능을 확장한 것입니다.
		- **Observable, Observer, 그리고 Disposable에 대해 설명해주세요.**
			- **Observable**: 이벤트 스트림을 나타내며, 데이터를 생성하고 방출하는 소스입니다.
			- **Observer**: Observable에서 방출되는 이벤트를 구독하여 처리하는 객체입니다.
			- **Disposable**: Observer가 Observable을 구독할 때 반환되는 객체로, 구독을 취소하고 리소스를 해제하는 데 사용됩니다.
		- **Subject와 Observable의 차이점은 무엇인가요?**
			- **Observable**: 이벤트를 방출하는 데이터 소스입니다.
			- **Subject**: Observable이면서 동시에 Observer인 개체로, 새로운 이벤트를 직접 발생시킬 수 있습니다.
		- **RxSwift의 주요 컴포넌트들을 나열하고 각각에 대해 설명해주세요.**
			- **Observable**: 비동기적으로 이벤트 스트림을 생성하는 기본 컴포넌트.
			- **Observer**: Observable이 방출하는 이벤트를 처리하는 컴포넌트.
			- **Operator**: 이벤트 스트림을 변환하고 조작하는 함수.
			- **Schedulers**: 작업을 어떤 스레드에서 실행할지 결정하는 컴포넌트.
		- **RxSwift에서의 Operator의 역할은 무엇인가요? 몇 가지 예시를 들어 설명해주세요.**
			- Operator는 Observable이 방출하는 아이템들을 변환하거나 조작하는 함수입니다.
			- 예를 들어, `map` 연산자는 각 아이템을 변환하고, `filter`는 조건에 맞는 아이템만 필터링합니다.
		- **RxSwift에서의 스케줄러(Scheduler)의 역할은 무엇이며 왜 중요한가요?**
			- **역할**: 스케줄러는 작업이 어느 스레드에서 실행될지를 결정합니다. 예를 들어, `MainScheduler`는 메인 스레드에서 작업을 실행합니다.
			- **중요성**: 올바른 스케줄러 사용은 비동기 작업의 관리와 성능을 향상시키며, 다양한 환경에서 안정성을 보장합니다.
		- **Observable의 생명주기에 대해 설명해주세요.**
			- **생성(Subscription)**: Observable이 구독되고, 이벤트 스트림이 생성됩니다.
			- **이벤트 발생**: Observable이 이벤트(Next, Error, Completed)를 방출합니다.
			- **구독 해지(Disposal)**: Observer가 Observable을 더 이상 구독하지 않을 때, 리소스를 정리하고 작업을 중지합니다.
		- **RxSwift에서의 Hot Observable과 Cold Observable의 차이점은 무엇인가요?**
			- **Cold Observable**: 구독 시마다 독립적인 이벤트 스트림을 생성하는 Observable입니다.
			- **Hot Observable**: 시간이 지나더라도 구독 여부와 관계없이 이벤트를 방출하는 Observable입니다.
		- **RxSwift에서의 Error Handling 방법은 어떻게 되나요?**
			- `catchError`: Observable에서 발생한 오류를 처리하거나 대체 값을 방출합니다.
			- `retry`: 오류가 발생했을 때 Observable을 재시도할 수 있도록 합니다.
			- `retryWhen`: 재시도를 커스텀하게 제어하는데 사용됩니다.
		- **RxCocoa에서의 주요 클래스들과 그 역할에 대해 설명해주세요.**
			- **Driver**: UI를 업데이트하기 위해 스레드 안전성을 제공하는 Observable 시퀀스입니다.
			- **ControlProperty**: UI 요소를 위한 읽기/쓰기 가능한 바인딩 프로퍼티입니다.
			- **ControlEvent**: UI 이벤트를 처리하는 Observable입니다.
		- **Bind, Subscribe, SubscribeOn, ObserveOn의 차이점은 무엇인가요?**
			- **Bind**: Observable을 UI나 다른 소스에 바인딩하여 값을 전달하고 업데이트하는 메서드입니다.
			- **Subscribe**: Observable을 구독하여 이벤트를 처리하고 결과를 얻습니다.
			- **SubscribeOn**: Observable이 어떤 스케줄러에서 작동할지를 설정하는 메서드입니다.
			- **ObserveOn**: Observable이 이벤트를 전달할 스케줄러를 변경하는 메서드입니다.
		- **RxSwift에서의 Memory Management에 대해 설명해주세요.**
			- RxSwift는 DisposeBag을 사용하여 메모리 누수를 방지합니다. DisposeBag은 Observable의 구독을 해제하고 리소스를 정리합니다.
		- **RxSwift를 사용할 때 주의해야 할 메모리 누수에 대해 어떻게 방지할 수 있는지 설명해주세요.**
			- `disposeBag`을 사용하여 구독을 추가하고, 해당 disposeBag을 정리하여 메모리 누수를 방지합니다.
			- Weak 참조나 unowned self를 사용하여 클로저 내부에서의 순환 참조도 방지할 수 있습니다.
		- **RxSwift의 MVVM 아키텍처에서 어떻게 사용되는지 설명해주세요.**
			- ViewModel이 Observable을 제공하고 View는 ViewModel을 구독하여 데이터를 업데이트합니다.
			- ViewModel은 비즈니스 로직을 처리하고, View는 UI를 나타냅니다.
		- **RxCocoa의 UITableView와 UICollectionView의 활용 방법에 대해 설명해주세요.**
			- `RxTableViewDataSourceType`와 `RxCollectionViewDataSourceType`을 사용하여 TableView와 CollectionView를 RxSwift와 바인딩할 수 있습니다.
			- Observable 데이터 소스를 구현하고, 이를 TableView 또는 CollectionView에 바인딩합니다.
		- **RxSwift를 사용하여 네트워크 요청을 처리하는 방법에 대해 설명해주세요.**
			- `Alamofire`와 결합하여 네트워크 요청을 Observable로 래핑하고, 이를 구독하여 요청을 실행하고 응답을 처리합니다.
		- **RxSwift에서의 Throttling과 Debouncing의 차이점은 무엇인가요?**
			- **Throttling**: 일정 주기마다 가장 최근 값만을 방출하고, 그 사이에 들어온 값은 무시하는 것입니다.
			- **Debouncing**: 일정 시간 동안 값이 들어오지 않을 때에만 값을 방출합니다. 새로운 값이 들어오면 타이머가 초기화됩니다.
		- **RxSwift에서의 Chaining과 Combining의 차이점은 무엇인가요?**
			- **Chaining**: 연속적으로 연산자를 적용하여 Observable을 변형하는 것입니다.
			- **Combining**: 두 개 이상의 Observable을 하나로 결합하여 새로운 Observable을 생성하는 것입니다.
		- **RxSwift에서의 Testing 방법에 대해 설명해주세요.**
			- **TestScheduler**: 테스트 시간을 제어하여 Observable의 행동을 시뮬레이션할 수 있습니다.
			- **subscribe(onNext:onError:onCompleted:onDisposed:)**: 특정 이벤트에 대한 테스트를 위해 Observable을 구독하여 결과를 검증할 수 있습니다.
		- **RxCocoa의 UI요소와의 상호작용 방법에 대해 설명해주세요.**
			- **ControlEvent**: UI 이벤트를 처리하는 Observable로, 버튼 탭이나 텍스트 필드 입력과 같은 이벤트를 처리할 수 있습니다.
			- **ControlProperty**: UI 요소의 값을 읽거나 쓸 수 있는 Observable 프로퍼티로, 텍스트 필드의 텍스트를 읽거나 설정할 때 사용됩니다.
		- **RxSwift에서의 Hot Observable과 Cold Observable을 사용할 때 적절한 상황은 어떤 경우인가요?**
			- **Cold Observable**: 개별적인 구독을 필요로 하는 상황에서 적합합니다. 각 구독이 독립적인 이벤트 스트림을 받아야 할 때 사용됩니다.
			- **Hot Observable**: 여러 구독자가 같은 이벤트 스트림을 공유하고자 할 때 사용됩니다. 예를 들어, 주식 가격 데이터를 여러 곳에서 공유할 때 적합합니다.
		- **RxSwift에서의 Connectable Observable은 무엇이며 어떻게 동작하나요?**
			- **Connectable Observable**: 구독할 때 이벤트를 방출하지 않고, `connect()`를 호출하여 연결된 후 이벤트를 방출합니다.
			- `connect()`가 호출되기 전까지는 실제로 이벤트를 방출하지 않으므로, 여러 구독자에게 동일한 이벤트 스트림을 공유하는 데 사용됩니다.
		- **RxSwift에서의 Buffering과 Windowing의 차이점은 무엇인가요?**
			- **Buffering**: 일정 기간이나 특정 조건에 따라 이벤트를 모아서 그룹화한 후 방출합니다.
			- **Windowing**: 일정 기간 또는 조건에 따라 새로운 Observable을 생성하여 이벤트를 그룹화하고 방출합니다.
		- **RxSwift에서의 Operators 중 Filtering, Transformation, Combination, 그리고 Error Handling을 각각 예시와 함께 설명해주세요.**
			- **Filtering**: `filter` 연산자로 조건에 맞는 값을 필터링합니다.
			- **Transformation**: `map` 연산자로 각 아이템을 변환합니다.
			- **Combination**: `merge`, `zip`, `combineLatest`와 같은 연산자로 여러 Observable을 결합합니다.
			- **Error Handling**: `catchError`, `retry`, `retryWhen`을 사용하여 오류를 처리합니다.
		- **RxSwift의 Subjects 중 PublishSubject, BehaviorSubject, ReplaySubject, AsyncSubject 각각의 특징과 사용 사례에 대해 설명해주세요.**
			- **PublishSubject**: 구독 이후의 새로운 이벤트만을 방출합니다. 이전의 이벤트는 전달되지 않습니다. 주로 런타임 이벤트 또는 구독 시점 이후의 이벤트를 처리할 때 사용됩니다.
			- **BehaviorSubject**: 초기 값을 가지고 있으며, 새로운 구독자에게 최근 값을 방출하고 그 후부터는 새로운 값만을 방출합니다. 초기 상태가 필요한 상황에서 사용됩니다.
			- **ReplaySubject**: 버퍼에 있는 일정 수의 이벤트를 저장하고, 새로운 구독자에게 저장된 이벤트를 방출합니다. 최근 이벤트를 다시 재생해야 할 때 사용됩니다.
			- **AsyncSubject**: 오직 Observable이 완료될 때까지만 값을 방출하며, 그 때 마지막 값만을 구독자에게 전달합니다. 작업이 완료되고 마지막 값을 처리해야 할 때 사용됩니다.
		- **RxSwift에서의 Multicasting이 무엇이며 어떻게 구현할 수 있나요?**
			- **Multicasting**: 하나의 Observable을 여러 개의 구독자에게 공유하는 것입니다.
			- `share()`, `publish().refCount()`, `multicast()`와 같은 연산자를 사용하여 Multicasting을 구현할 수 있습니다.
		- **RxSwift에서의 Backpressure는 무엇이며 어떻게 처리되나요?**
			- **Backpressure**: Observable이 너무 빠르게 이벤트를 방출하여 소비자가 처리할 수 없는 상황을 의미합니다.
			- `buffer`, `throttle`, `debounce` 등의 연산자를 사용하여 Backpressure를 제어하고 처리합니다.
		- **RxCocoa에서의 ControlProperty와 ControlEvent의 차이점은 무엇인가요?**
			- **ControlProperty**: 읽기 및 쓰기 가능한 속성을 나타내며, UI 요소의 값을 설정하고 읽을 수 있습니다.
			- **ControlEvent**: UI 요소에서 발생하는 이벤트를 나타내며, 주로 UI 이벤트를 처리하기 위해 사용됩니다.
- 링크 가져오기
	- https://github.com/Edison-Hsu/100-days-of-RxSwift
	- https://github.com/devxoul/RxTodo
- https://samvlu.com/index.html
-